SetSeed(12345);

function SquareCode(C)
    F := BaseField(C);
    G := GeneratorMatrix(C);
    n := Length(C);
    k := Dimension(C);
    G2 := Matrix([[G[tup[1],l]*G[tup[2],l] : l in [1..n]] : tup in CartesianPower([1..k],2) | tup[1] le tup[2]]);
    return LinearCode(G2);
end function;

function QuadraticHull(G)
    n := Ncols(G);
    k := Nrows(G);
    G2 := Matrix([[G[tup[1],l]*G[tup[2],l] : l in [1..n]] : tup in CartesianPower([1..k],2) | tup[1] le tup[2]]);
    return Basis(Kernel(G2));
end function;

function MatrixOfPolarForm(rel,k)
    M := ZeroMatrix(BaseRing(rel),k,k);
    count := 1;
    for i in [1..k] do
        for j in [i..k] do
            if i eq j then
                M[i,i] := 2*rel[count];
            else 
                M[i,j] := rel[count];
                M[j,i] := rel[count];
            end if;
            count := count + 1;
        end for;
    end for;
    return M;
end function;

function ExtendSquareMatrix(Mat,M,RemovedIndices)
    Res := ZeroMatrix(BaseRing(Mat),M,M);
    Indices := [i : i in [1..M] | not i in RemovedIndices];
    NI := #Indices;
    assert NI eq Ncols(Mat);
    for i in [1..NI] do 
        for j in [1..NI] do 
            Res[Indices[i],Indices[j]] := Mat[i,j];
        end for;
    end for;
    return Res;
end function;

q := 2;
r := 6;
m := 10;

n := q^m;

Fq<zz> := GF(q);
Fqm<a> := GF(q^m);

goppa := true;
partial_pfaffians := true;

Support := SetToSequence(RandomSubset(Set(Fqm),n));
sigma := Random(Sym(n));
Support := [Support[i^sigma] : i in [1..n]];

if goppa then
    Gamma := IrreduciblePolynomial(Fqm,r);
    Multiplier := [1 / Evaluate(Gamma,x) : x in Support];
    e := Floor(Log(4,2*r-1));
    f_hat := (2*e+2)*r - (4^(e+1)-1)/3;
    print "f = ",f_hat;
    C := Dual(AlternantCode(Support,Multiplier,r,Fq));
 else
    Multiplier := [a^Random([1..q^m-1]) : _ in [1..n]];
    e := Floor(Log(q,r-1));
    f_hat := (e+1)*r - (q^(e+1)-1)/(q-1);
    print "f = ",f_hat;
    C := Dual(AlternantCode(Support,Multiplier,r,Fq));
end if;

// C := RandomLinearCode(Fq,n,r*m);

eG := Floor(Log(4,r));
sG := 2 * ((eG+1)*r - (4^(eG+1)-1)/3);
// Change this if need be
s := Floor(sG)+1;
print "Shortening ", s , " times\n";
k := r*m-s;

Group := Sym(r*m);

sigma := Random(Group);
RemovedIndices := [i^sigma : i in [1..s]];

G := Submatrix(GeneratorMatrix(C),[i : i in [1..r*m] | not i in RemovedIndices],[j : j in [1..n] | not j in RemovedIndices]);

G2 := Matrix([[G[tup[1],l]*G[tup[2],l] : l in [1..n-s]] : tup in CartesianPower([1..k],2) | tup[1] le tup[2]]);

K := Basis(Kernel(G2));

Cmat := [MatrixOfPolarForm(rel,k) : rel in K];
N := #Cmat;

print "N = ", N;
print Ncols(Cmat[1]);
// Change this according to the size of the dense block (see Heuristic 2)
print &+[Binomial(r*m-s-i,3) : i in [1..13]];
print Binomial(r*m-s,4);

PrintFile("Cmat.txt",Ncols(Cmat[1]));
PrintFile("Cmat.txt",N);
PrintFile("Cmat.txt", Cmat);
